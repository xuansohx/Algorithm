PART01. C++로의 전환

## CH01 - C언어 기반의 C++ ①

> 20.01.13.Mon

### 1. printf와 scanf를 대신하는 입출력 방식

:snowflake: 문자열 "Hello World"의 출력

``` c++
#include <iostream>
int main(void){
    int num=20;
    std::cout<<"Hello World"<<std::endl;
    std::cout<<"Hello "<<"World"<<std::endl;
    std::cout<<num<<' '<<'A';
    std::cout<<' '<<3.14<<std::endl;
    return 0;
}
```

1) 헤더파일 선언문 `#include <iostream>`

- C언어에서 입출력을 목적으로 사용하던 헤더파일 `<stdio.h>`와 같은 것

- C++에서는 입출력에 관련된 일을 하기 위해서 `<iostream>`을 사용

  > std, cout, edl을 사용하기 위함

- 위의 헤더파일은 확장자 `.h`가 없음 -> 표준 헤더파일에서는 생략하기로 약속

- 간혹 확장자가 있는 헤더파일은 버전의 차이! 없는 것이 new version

2) `std::cout`과 `<<`연산자를 이용한 출력

``` c++
std::cout<<'출력대상';
```

- '출력대상'의 위치에는 무엇이든 올 수 있음

  > 정수와 실수를 비롯한 문자열, 변수 등 모두 가능

- C언어의 `print` 함수는 `%d` `%s` 등 서식문자를 이용하여 별도의 출력포맷을 지정했으나, 여기에서는 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이루어짐

``` c++
std::cout<<'출력대상1'<<'출력대상2'<<'출력대상3';
```

- 둘 이상의 출력대상을 연이어서 출력 할 수도 있음

:snowman: `scanf`를 대신하는 데이터의 입력

``` c++
#include <iostream>
int main(void){
    int val1;
    std::cout<<"첫 번째 숫자입력: ";
    std::cin>>val1;
    
    int val2;
    std::cout<<"두 번째 숫자입력: ";
    std::cin>>val2;
    
    ...
        
}
```

- 키보드로부터의 데이터 입력에도 헤서파일 선언문 `#include <iostream>` 이 필요

``` c++
std::cin>>'변수';
```

- 키보드로부터의 데이터 입력에는 `std::cin`과 `>>` 연산자가 사용

  > `>>` 뒤의 변수에 입력 받은 데이터를 저장
  >
  > 데이터의 입력 또한 출력과 마찬가지로 별도의 포맷 지정이 필요 없음

- 변수의 선언은 어디에서도 가능 (지역변수)

  > 과거의 C는 맨 위에서 모든 변수를 선언하도록 제한하였으나, 위의 예시를 보면 val1과 val2이 필요에 따라 각각 다른 위치에서 선언되었음을 알 수 있음

- (지역)변수의 선언은 어디에서든 가능하기 때문에 for문 안에서 선언과 동시에 초기화하는 것도 가능

``` c++
std::cin>>val1>>val2;
```

- 입력 받은 순서대로 val1과 val2에 채워짐 
  - 이때 입력되는 데이터의 구분은 탭, 스페이스바, Enter 키의 입력과 같은 공백에 의해 나눠짐



### 2. 함수의 오버로딩 (Function Overloading)

``` c++
int MyFunc(int num){
    num++;
    return num;
}

int MyFunc(int a, int b){
    return a+b;
}
```

- 하나의 프로젝트 내 동일한 이름의 함수가 있으면?

  - C언어에서는 동일한 이름의 함수가 정의되는 것을 허용하지 않음

    ∵ 오직 함수의 이름만 이용해서 호출대상을 찾기 때문에, 매개변수가 다른 두 함수를 구분하지 못 함

  - C++언어에서는 함수호출 시 전달되는 인자를 통해서 호출하고자 하는 대상을 찾기 때문에 함수의 구분이 가능 (C++은 **함수의 이름**과 **매개변수의 선언**을 확인하여 함수를 찾음) :star:

- 함수의 이름은 동일한데 자료형, 개수가 다른 함수를 가리켜 **함수 오버로딩(Function Overloading)**이라 함

Example

``` c++
int MyFunc(char c){...}
int MyFunc(int n){...}
// 자료형이 다르기 때문에 함수 오버로딩 성립

int MyFunc(int n){...}
int MyFunc(int n1, int n2){...}
// 매개변수의 수가 다르므로 함수 오버로딩 성립

void MyFunc(int n){...}
int MyFunc(int n){...}
// 반환형의 차이는 함수 오버로딩의 조건을 만족하지 않음
```

<br>

> 20.01.14.Tue

### 3. 매개변수의 디폴트 값 (Default Value)

- **Default Value**란 '기본적으로 설정되어 있는 값'

``` c++
int MyFuncOne(int num=7){...}
int MyFuncTwo(int num1=5, int num2=7){...}
```

- 함수호출 시 괄호 안의 인자를 전달되는 것으로 간주하는 것

  > num, num1, num2에 대한 정의가 없으면 위에 정의된 default value가 매개변수에 전달

- Default Value의 선언은 함수의 선언부분에 위치해야 됨 (상단)

- Default Value가 선언되어 있어도 별도의 매개변수의 인자 전달 가능

Example

``` c++
# include <iostream>
int Adder(int num1=1, int num2=2)
{ // Adder의 default value로 1과 2가 설정
    return num1+num2;
}

int main(void){
    std::cout>>Adder()>>std::endl; // one
    std::cout>>Adder(5)>>std::endl; // two
    std::cout>>Adder(3,5)>>std::endl; // three
    return 0;
}
```

> - one : Adder 함수를 호출할 때 인자를 전달하지 않으니, default 값인 1,2가 전달된 것으로 간주
> - two : Adder 함수를 호출할 때 하나의 인자만 전달하기 때문에, 첫 번째 매개변수는 5 나머지는 default 값인 2가 전달
> - three : 두 개의 인자를 모두 전달하기 때문에 default 값은 의미가 없음:

:christmas_tree: **부분적 Default Value 설정**

``` c++
int FuncOne(int num1=3, int num2=5, int num3=7){...} // dafault value 전부 지정
int FuncTwo(int num1, int num2=5, int num3=7){...} // default value 일부만 지정
```

- default 값은 전부 지정할 수도 있지만 일부분만 지정하는 것도 가능

- 부분적으로 지정을 할 때는 오른쪽이 아닌 **왼쪽을 비우는 형태**로만 가능 (오른쪽만 비어있는 형태는 안됨) :star:

- 함수로 전달되는 인자가 왼쪽에서부터 오른쪽으로 채워지기 때문에,

  default 값의 오른쪽만 비워지면 매개변수의 일부만 채워지므로 컴파일 에러를 일으킴

Example : :blush: :o:

``` c++
int FuncOne(int num1, int num2, int num3=30){...}
int FuncTwo(int num1, int num2=20, int num3=30){...}
int FuncThree(int num1=10, int num2=20, int num3=30){...}
```

Example : :scream: :x:

``` c++
int FuncOne(int num1=10, int num2, int num3){...}
int FuncTwo(int num1=10, int num2=20, int num3){...}
```



### 4. 인라인(inline) 함수

:heavy_check_mark: 인라인(inline) 함수 공부에 앞서 **매크로 함수**에 대하여 공부하기 : [TCP School 참고](http://tcpschool.com/c/c_prepro_macroFunc)

매크로 함수의 정의 및 사용

- 매크로 함수란? `#define` 선행처리 지시문에 인자를 전달하여, 함수처럼 동작하는 매크로 -> **치환 형태**
- 이러한 매크로를 함수 같은 매크로(function-like macro) 또는 매크로 함수라고 함

``` c++
#include <stdio.h>
#define SUB(X,Y) X-Y
#define PRT(X) printf("계산 결과는 %d입니다.\n",X)

int main(void){
    int result;
    int num1=15, num2=7;
    
    result=SUB(num1, num2);
    PRT(result);
    return 0;
}
```

> 실행 결과 : 계산 결과는 8입니다.

- 매크로 함수는 일반 함수와는 달리 단순 치화만 해주기 때문에, 일반 함수와 완전히 똑같은 방식으로 동작하지는 않음 :star: **괄호**가 중요함 :star:

``` c++
#include <stdio.h>
#define SQR(X) X*X
#define PRT(X) printf("계산 결과는 %d입니다.\n", X)

int main(void){
    int result; 
    int x=5;
    
    result=SQR(10);
    PRT(result);
    result=SQR(x);
    PRT(result);
    result=SQR(x+3);
    PRT(result);
    
    return 0;
}
```

> 실행 결과 : 100 / 25 / 23 -> 세 번째 결과는 예상과 달리 다른 결과 값을 반환

:round_pushpin: 일반 함수는 인수를 프로그램이 실행 중일 때 전달 받지만, 매크로 함수는 컴파일 이전에 미리 치환하기 때문

> (x+3) 연산 후, X 자리에 들어가 계산되어야 하는데, 'x+3'인 '5+3' 형태로 들어가기 때문에 예상과 다르게 계산 
>
> 'x+3 * x+3 = 5+3 * 5+3 = 5+15+3 = 23' 이렇게 계산이 돼 예상과 다른 결과가 나옴 (예상 결과 : 8*8=64)

- 위의 문제를 방지하기 위하여 아래와 같이 괄호를 사용하여 매크로를 정의

```C++
#include <stdio.h>
#define SQR(X) ((X)*(X))
#define PRT(X) printf(" ... ",X)
```

> - 매크로 함수의 전체를 괄호로 감싸기
> - 매크로 함수의 인수들도 각각 괄호로 감싸기
> - 증감 연산자(++,--)나 복합 대입 연산자 등의 사용은 권장하지 않음

매크로 함수의 장점 및 단점

- 매크로 함수의 장점
  - 단순 치환만을 해주기 때문에 인수의 타입은 신경쓰지 않아도 됨
  - 여러 개의 명령문을 동시에 포함할 수 있음
  - 함수 호출에 의한 성능 저하가 일어나지 않기 때문에, 프로그램의 실행속도가 향상
- 매크로 함수의 단점
  - 원하는 결과를 얻는 정확한 매크로 함수의 구현과 디버깅이 어려움
  - 매크로 함수의 크기가 증가할 수록 사용되는 괄호가 많아져 복잡하고 가독성이 떨어짐

-----------------------

:heavy_check_mark: 매크로와 인라인 비교하여 공부하기 ... ing