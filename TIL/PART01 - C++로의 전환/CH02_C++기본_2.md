PART01. C++로의 전환

## CH2 - C언어 기반의 C++ ②

> 20.01.17.Fri

### 1. C언어 복습

#### 1-1. 키워드 `const`의 의미

- `const`는 'constant'의 약자로 변수 앞에 붙이면 **한 번 설정된 값이 변경되지 않음**

  -> `const`를 붙인 변수의 초기값을 변경하면 컴파일 에러

- 상수 뿐 아니라 포인터의 값도 변경할 수 없음

``` c++
const (자료형) (상수명) = (상수값)
```

``` c++
const int num = 10; // 변수 num을 상수화
const int * ptr1 = &val1; // 포인터 ptr1을 이용해서 val1의 값을 변경할 수 없음
int * const ptr2 = &val2; // 포인터 ptr2가 상수화 됨
const int * const ptr3 = &val3; // 포인터 ptr3가 상수화 되었으며, ptr3를 이용해서 val3의 값을 변경할 수 없음
```

Example

``` c++
int main(){
    const int _Max = 0; // 선언과 동시에 초기화
    _Max = 10; // const로 선언하였기 때문에 주소와 값을 변경할 수 없음 -> 컴파일 에러
}
```

:green_apple: 포인터와 포인터 변수

- 어떠한 값을 저장하는게 아니라 어떠한 값의 주소(Address)를 저장하는 것
- 변수의 이름 앞에 '*'를 붙이면 포인트 변수가 됨

``` c++
(자료형) *(변수명);

Example
int a = 0; // 일반 변수
int *p = NULL; // 포인터 변수
```

- 변수에 '&'를 붙이면 주소의 값이 저장됨

```c++
p = &a; // a의 주소를 p에 저장
```

- 포인터 변수의 `const` 키워드 사용 -> 붙이는 위치에 따라 다른 설정

> `const`가 앞에 붙는 경우에는 포인터 변수 안에 값을 변경할 수 없고,  `const`가 뒤에 붙는 경우에는 포인터 변수의 주소 값을 변경할 수 없음

Example

``` c++
// const가 앞에 붙는 경우
int nTotal = 0;
const int *_Max;
_Max = &nTotal;
*_Max = 10; // 에러

// const가 뒤에 붙는 경우
int nTotal = 0;
int * const _Max = &nTotal;
_Max = &nTotal; // 에러
*_Max = 10;

// const를 앞뒤로 붙이는 경우
int nTotal = 0;
const int * const _Max = &nTotal;
_Max = &nTotal; // 에러
*_Max = 10; // 에러
```



#### 1-2. 메모리의 구조

- 프로그램을 실해시키면 **운영체제**는 우리가 실행시킨 프로그램을 위해 **메모리 공간**을 할당해 줌
- 프로그램이 메모리에 로드(load) 되어야 실행할 수 있으며 사용되는 변수를 저장하기 위한 메모리도 필요

:strawberry: **데이터(Data) 영역**

- 프로그램 시작과 동시에 할당되며, 프로그램이 종료되면 소멸
- 전역변수와 정적(static) 변수가 저장되는 영역

:mandarin: **스택(Stack) 영역**

- 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역

- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸

- 스택 영역에 저장되는 함수의 호출 정보를 **스택 프레임(stack frame)**이라고 함

- 스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출 -> **후입선출(LIFO, Last-In First-Out)** 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출

  ∴ **높은 주소에서 낮은 주소**로 할당

:banana: **힙(Heap) 영역**

- 내가 명령을 해야만 메모리가 할당되고 지워짐 -> `malloc`과 `free` 함수 활용

  > `mallcoc` 함수에 의해 메모리 공간이 할당되며,  `free` 함수에 의하여 메모리 공간 소멸

- 컴파일 타임(compile time)이 아닌 **런 타임(run time)**에 

  사용자가 직접 메모리 영역의 크기를 결정하는 **동적할당(Dynamic Allocation)**

- 힙 영역은 메모리의 **낮은 주소에서 높은 주소의 방향**으로 할당

> 실행할 프로그램의 코드가 저장되는 영역인 코드(code) 영역을 구분하기도 함 -> CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리



#### 1-3. `Call-by-value` vs `Call-by-reference`

함수의 호출형태에 따라 나눔

- 값에 의한 호출 `Call-by-value`
- 참조에 의한 호출 `Call-by-reference`

Example

``` c++
// Call-by-value
void SwapByValue(int num1, num2){
    int temp=num1;
    num1=num2;
    num2=temp;
}

// Call-by-reference
void SwapByRef(int * ptr1, int * ptr2){
    int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr2 = temp;
}
```

