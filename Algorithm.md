## Algorithm

- 유한한 단계를 통해 컴퓨터가 문제를 해결하기 위한 절차나 방법
- 알고리즘 표현법
  - 슈도코드 : 코드 그 자체
  - 순서도 : 전체적인 흐름과 과정 파악을 위한 데이터의 처리과정을 도식화 하여 나타낸 것

- 무엇이 좋은 알고리즘인가? 
  - 정확성 | 작업량 | 메모리 사용량 | 단순성 | 최적성

- 알고리즘의 성능 분석
  - 알고리즘의 작업량 비교
  - 시간 복잡도(Time Complexity)
    - 실제 걸리는 시간을 측정
    - **실행되는 명령문의 개수**를 계산

--------

:blossom: 알고리즘 풀이를 위한 개념과 자료구조 정리하기​

### 1. Array

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

:round_pushpin: Array(배열)의 필요성

- 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적
- 다수의 변수로는 하기 힘든 작업을 Array를 활용해 쉽게 할 수 있음 -> 한 번의 선언으로 여러 개의 자료형 처리

------

### 2. Sort

두 개 이상의 자료를 특정 기준에 의해 정렬하는 것

> 작은 값부터 큰 값으로 정렬하는 오름차순(ascending)과 그 반대인 내림차순(descending)

#### 2-1. Selection Sort

- Selection Sort는 Bubble Sort와 유사한 알고리즘

- 해당 순서에 어떤 원소를 넣을지 선택하는 알고리즘

Solution

1. 주어진 배열 중 최솟값 혹은 최댓값을 찾아 맨 앞에 위치한 값과 교체
2. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체함 / 이중 for문 사용

Example

```c++
// 오름차순으로 정렬
for(i=0; i<n-1; i++){ // 첫 번째 for문
		idx=i; // 최솟값은 idx로 옴
		for(j=i+1; j<n; j++){ // 두 번째 for문
			if(a[j]<a[idx]) idx=j;
		}
		tmp=a[i]; // 최솟값으로 갱신하는 과정
		a[i]=a[idx];
		a[idx]=tmp;
	}
```

1. 첫 번째 for문을 활용하여 해당하는 위치(idx)에 최솟값을 갱신
2. 이때 두 번째 for문을 활용하여 주어진 배열의 나머지 값과 비교하여 최솟값을 찾을 수 있음

> 두 번째 for문에서 사용하는 j는 항상 첫 번째 for문의 i보다 항상 뒤에 위치함 ∴ j=i+1

3. 최솟값이 발견되면 맨 앞(idx)으로 옮김

#### 2-2. Bubble Sort

- 서로 이웃한 두 수를 계속 비교하여 조건에 따라 자리를 교환하여 정렬하는 알고리즘 :sweat_drops:

- 시간복잡도는 **O(n^2)**으로 가장 비효율적

  ∵ Selection Sort는 한 번 쭉 순회하고 교환하지만, Bubble Sort는 계속 비교하면서 교환 및 순회하기 때문

Solution

1. 첫 번째 원소와 두 번째 원소, 두 번째와 세 번째, 세 번째와 네 번째 원소, ... 를 비교하여 마지막 원소의 위치에 조건에 맞는 원소를 갱신
2. 1회전이 끝나면 2회전도 위와 같은 방법으로 (마지막-1)번째 원소를 조건에 맞게 갱신

Example

``` c++
// 오름차순으로 정렬
for(j=0; j<n-i-1; j++){
    if(a[j]>a[j+1]){
        ...
    }        
}
```

#### 2-3. Insertion Sort

:heavy_check_mark: 입사시험 중 손코딩 문제에서 많이 출제됨 ★★★

- Selection Sort와 유사하지만, 좀 더 효율적인 정렬 알고리즘

- 두 번째 원소부터 시작하여 해당 위치(index)의 값을  temp에 저장한 후, 앞의 원소들과 비교하며 삽입
- 시간복잡도는 **O(N)**으로 빠른 효율성을 갖는 알고리즘